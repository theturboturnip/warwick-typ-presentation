% COULDN'T UPLOAD TO MENDELEY SO USED MANUALLY INSTEAD

% Used for citing turbulent eddy viscosity (at least it covers it in more depth)
@book{bird2006transport,
  title={Transport Phenomena},
  author={Bird, R.B. and Stewart, W.E. and Lightfoot, E.N.},
  number={v. 1},
  isbn={9780470115398},
  lccn={2001023739},
  series={Transport Phenomena},
%   url={https://books.google.co.uk/books?id=L5FnNlIaGfcC},
  year={2006},
  publisher={Wiley}
}

% Colocated Grids
@article{peric1988comparison,
  title={Comparison of finite-volume numerical methods with staggered and colocated grids},
  author={Peri{\'c}, M and Kessler, R and Scheuerer, G},
  journal={Computers \& Fluids},
  volume={16},
  number={4},
  pages={389--403},
  year={1988},
  publisher={Elsevier}
}

% Used to explain delta-t safety factor
@article{TOME1994171,
title = "GENSMAC: A Computational Marker and Cell Method for Free Surface Flows in General Domains",
journal = "Journal of Computational Physics",
volume = "110",
number = "1",
pages = "171--186",
year = "1994",
issn = "0021-9991",
doi = "https://doi.org/10.1006/jcph.1994.1013",
url = "http://www.sciencedirect.com/science/article/pii/S0021999184710138",
author = "Murilo F. Tome and Sean McKee",
abstract = "A computer program for solving two-dimensional incompressible viscous fluid flow in general domains is described. This is based on the simplified Marker and cell technique, but it has a number of novel features. A user-supplied data file of coordinates prescribes the fluid domain which can be quite general and needs only to be connected. With a view to parallelisation the momentum equations are solved explicitly, but an automatic step-changing routine optimises the stability restriction. A conjugate gradient solver is used to invert the discrete Poisson equation. An accurate approximation to the stress conditions on the free surface is adopted. The code is written in structured FORTRAN with features from FORTRAN 90. The efficacy of the code is illustrated by applying it to some industrial problems."
}

% Used for citing Reynolds Number
@book{falkovich2018fluid,
  title={Fluid Mechanics},
  author={Falkovich, G.},
  isbn={9781107129566},
  lccn={2017049966},
%   url={https://books.google.co.uk/books?id=OEFPDwAAQBAJ},
  year={2018},
  publisher={Cambridge University Press}
}

% Partial second derivatives for discrete values 
@inproceedings{hirt1976,
    author       = {Nichols, B. D. and Hirt, C.W.},
  editor       = {Schot, Joanna W. and Salvesen, Nils},
  title        = {Methods for Calculating Multi-Dimensional, Transient, Free Surface Flows Past Bodies},
  date         = {1975},
  booktitle    = {First International Conference on Numerical Ship Hydrodynamics},
  eventdate    = {1975-10-20/1975-10-22},
  publisher    = {David W. Taylor Naval Ship Research and Development Center},
    pages={253--278},
}

% Origin of multicolored SOR, could not find the PDF
@book{young1971iterative,
    title={Iterative Solution of Large Linear Systems},
    author = {Young, David M.},
    year={1971},
}

% Using multicolored SOR for parllel computaion
@inproceedings{Adams1982AMS,
  title={A multi-color SOR method for parallel computation},
  author={L. Adams and J. Ortega},
  booktitle={ICPP},
  pages={53--56},
  year={1982}
}

% L2 norm
@inbook{l2norm,
editor="Li, Stan Z.
and Jain, Anil",
title="L2 norm",
bookTitle="Encyclopedia of Biometrics",
year="2009",
publisher="Springer US",
address="Boston, MA",
pages="883--883",
isbn="978-0-387-73003-5",
doi="10.1007/978-0-387-73003-5_1070",
url="https://doi.org/10.1007/978-0-387-73003-5_1070"
}

% My ACA submission
@article{modules:aca257submission,
title="CS257 Report - Reducing the Execution Time of a Fluid Simulation Program",
year="2020",
author={Stark, S.}
}


% GPU ACCELERATED RED/BLACK SOR
% Used for simplified navier-stokes, plus something else?
@article{paper:GpuAcceleratedRedBlack,
author = {Liu, Ji and Ma, Zhao and Li, Shi and Zhao, Ying},
year = {2011},
month = {08},
pages = {335-340},
title = {A GPU Accelerated Red-Black SOR Algorithm for Computational Fluid Dynamics Problems},
volume = {320},
journal = {Advanced Materials Research},
doi = {10.4028/www.scientific.net/AMR.320.335}
}

% Evidence of CFD used for fire modelling
@article{Sullivan_2009,
   title={Wildland surface fire spread modelling, 1990 - 2007. 1: Physical and quasi-physical models},
   volume={18},
   ISSN={1049-8001},
   url={http://dx.doi.org/10.1071/WF06143},
   DOI={10.1071/wf06143},
   number={4},
   journal={International Journal of Wildland Fire},
   publisher={CSIRO Publishing},
   author={Sullivan, Andrew L.},
   year={2009},
   pages={349}
}

% Evidence of CFD for aerodynamics
@inproceedings{jameson2002,
  title={Using computational fluid dynamics for aerodynamics--a critical assessment},
  author={Jameson, Antony and Martinelli, Luigi and Vassberg, J},
  booktitle={Proceedings of ICAS},
  pages={2002--1},
  year={2002}
}

% VK_KHR_external_memory_fd
@misc{tool:VulkanKHRExternalMemoryFD,
    title={VK_KHR_external_memory_fd},
    url={https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_external_memory_fd.html},
    author={Jones, James and Juliano, Jeff},
    organization={The Khronos Group Inc},
    year={2016}
}


%
% COPIED FROM MENDELEY GARBAGE FIRE
%
% @inproceedings{Kreylos2002,
%   author = {O Kreylos and A M Tesdall and B Hamann and J K Hunter and K I Joy},
%   city = {Goslar, DEU},
%   isbn = {158113536X},
%   journal = {Proceedings of the Symposium on Data Visualisation 2002},
%   pages = {25–34},
%   publisher = {Eurographics Association},
%   title = {Interactive Visualization and Steering of CFD Simulations},
%   year = {2002},
% }

% @inproceedings{Dice2018,
%   abstract = {Molecular simulations are increasingly used to study nanoscale biological and synthetic systems. To model interactions between molecules, we look to Brownian Dynamics. An n-body problem, the calculation of pairwise forces between molecules is naively an O(n2) algorithm. In our work, we begin with a single-threaded C++ code, simulating toluene (C6H5CH3) molecules suspended in water and their interaction with a graphene sheet. Our goal was to study algorithmic improvements for n-body problems and benchmark implementations along the way. We reduce computational cost with Verlet pairlists and cell decomposition and explored strategies to optimize cache utilization. Finally, we implement and benchmark a CUDA-accelerated code targeting the NVIDIA GeForce GTX 1080 Ti GPU.},
%   author = {Kevin Dice and Cortez Gray and George Walker and Cody Baldwin and Daniel Andresen},
%   city = {New York, NY, USA},
%   doi = {10.1145/3219104.3229260},
%   isbn = {9781450364461},
%   journal = {Proceedings of the Practice and Experience on Advanced Research Computing},
%   keywords = {Brownian Dynamics,CUDA,Molecular Simulation},
%   publisher = {Association for Computing Machinery},
%   title = {CUDA-Accelerated Simulation of Brownian Dynamics},
%   url = {https://doi.org/10.1145/3219104.3229260},
%   year = {2018},
% }

% @inproceedings{Reynolds1987,
%   abstract = {The aggregate motion of a flock of birds, a herd of land animals, or a school of fish is a beautiful and familiar part of the natural world. But this type of complex motion is rarely seen in computer animation. This paper explores an approach based on simulation as an alternative to scripting the paths of each bird individually. The simulated flock is an elaboration of a particle system, with the simulated birds being the particles. The aggregate motion of the simulated flock is created by a distributed behavioral model much like that at work in a natural flock; the birds choose their own course. Each simulated bird is implemented as an independent actor that navigates according to its local perception of the dynamic environment, the laws of simulated physics that rule its motion, and a set of behaviors programmed into it by the "animator." The aggregate motion of the simulated flock is the result of the dense interaction of the relatively simple behaviors of the individual simulated birds.},
%   author = {Craig W. Reynolds},
%   city = {New York, New York, USA},
%   doi = {10.1145/37401.37406},
%   isbn = {0897912276},
%   journal = {Proceedings of the 14th Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH 1987},
%   keywords = {Actor,Aggregate motion,Behavioral animation,Bird,Constraints,Fish,Flight,Flock,Herd,Particle system,Path planning,School},
%   month = {8},
%   pages = {25-34},
%   publisher = {Association for Computing Machinery, Inc},
%   title = {Flocks, herds, and schools: A distributed behavioral model},
%   url = {http://portal.acm.org/citation.cfm?doid=37401.37406},
%   year = {1987},
% }

% @inproceedings{Memeti2017,
%   abstract = {Many modern parallel computing systems are heterogeneous at their node level. Such nodes may comprise general purpose CPUs and accelerators (such as, GPU, or Intel Xeon Phi) that provide high performance with suitable energy-consumption characteristics. However, exploiting the available performance of heterogeneous architectures may be challenging. There are various parallel programming frameworks (such as, OpenMP, OpenCL, OpenACC, CUDA) and selecting the one that is suitable for a target context is not straightforward. In this paper, we study empirically the characteristics of OpenMP, OpenACC, OpenCL, and CUDA with respect to programming productivity, performance, and energy. To evaluate the programming productivity we use our homegrown tool CodeStat, which enables us to determine the percentage of code lines required to parallelize the code using a specific framework. We use our tools MeterPU and x-MeterPU to evaluate the energy consumption and the performance. Experiments are conducted using the industry-standard SPEC benchmark suite and the Rodinia benchmark suite for accelerated computing on heterogeneous systems that combine Intel Xeon E5 Processors with a GPU accelerator or an Intel Xeon Phi co-processor.},
%   author = {Suejb Memeti and Lu Li and Sabri Pllana and Joanna Ko\lodziej and Christoph Kessler},
%   city = {New York, NY, USA},
%   doi = {10.1145/3110355.3110356},
%   isbn = {9781450351164},
%   journal = {Proceedings of the 2017 Workshop on Adaptive Resource Management and Scheduling for Cloud Computing},
%   keywords = {CUDA,OpenACC,OpenCL,OpenMP,energy consumption,performance,programming productivity},
%   pages = {1–6},
%   publisher = {Association for Computing Machinery},
%   title = {Benchmarking OpenCL, OpenACC, OpenMP, and CUDA: Programming Productivity, Performance, and Energy Consumption},
%   url = {https://doi.org/10.1145/3110355.3110356},
%   year = {2017},
% }

% @inproceedings{Miyajima2017,
%   abstract = {Moving Particle Semi-implicit (MPS) method is a particle method used in fields such as computational fluid dynamics. It is classified as a particle method. Target fluids and objects are divided up into particles, and each particle interacts with its neighbour-particle. The search for neighbour-particle is the main bottleneck of the MPS method. In this paper, we port and optimize "search for neighbour-particle" part in MPS method for GPU by using OpenACC. It accounted for 56% of all the processing time. We present three different optimizations and evaluated them with three different data sets; 25,704, 224,910 and 2,247,750 particles. We also use four different GPUs; NVIDIA K20c, GTX1080, P100(PCIe) and P100(NVlink). As a result, P100(NVlink) GPU achieves 41.5 times speed-up compared with 24 MPI process CPU version when the number of particles is 2,247,750.},
%   author = {Takaaki Miyajima and Kenichi Kubota and Naoyuki Fujita},
%   city = {New York, NY, USA},
%   doi = {10.1145/3120895.3120903},
%   isbn = {9781450353168},
%   journal = {Proceedings of the 8th International Symposium on Highly Efficient Accelerators and Reconfigurable Technologies},
%   keywords = {GPU,MPS,Moving Particle Semi-implicit,OpenACC,Performance optimization},
%   publisher = {Association for Computing Machinery},
%   title = {A Porting and Optimization of Search for Neighbour-Particle in MPS Method for GPU by Using OpenACC},
%   url = {https://doi.org/10.1145/3120895.3120903},
%   year = {2017},
% }
% @inproceedings{Diarra2018,
%   abstract = {Many procedural languages, such as C and C++, have pointers. Pointers are powerful and convenient, but pointer aliasing still hinders compiler optimizations, despite several years of research on pointer aliasing analysis. Because alias analysis is a difficult task and results are not always accurate, the ISO C standard 99 has added a keyword, named restrict to allow the programmer to specify non−aliasing as an aid to the compiler′s optimizer and to thereby possibly improve performance. The task of annotating pointers with the restrict keyword is still left to the programmer. This task is, in general, tedious and prone to errors especially since the C does not perform any verification to ensure that restrict keyword is not misplaced. In this paper we present a static analysis tool that (i) finds CUDA kernels call sites in which actual parameters do not alias; (ii) clones the kernels called at such sites; (iii) after performing an alias analysis in these kernels, adds the restrict keyword to their arguments; and (iv) replaces the original kernel call by a call to the optimized clone whenever possible.},
%   author = {Rokiatou Diarra},
%   city = {New York, NY, USA},
%   doi = {10.1145/3238147.3241533},
%   isbn = {9781450359375},
%   journal = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
%   keywords = {CUDA,GPU,aliasing,compilers,program optimization,restrict},
%   pages = {928–931},
%   publisher = {Association for Computing Machinery},
%   title = {Towards Automatic Restrictification of CUDA Kernel Arguments},
%   url = {https://doi.org/10.1145/3238147.3241533},
%   year = {2018},
% }
% @inproceedings{Li2018,
%   abstract = {Based on various optimizations, this paper presents a performance comparison between CUDA and OpenACC using 19 kernels in 10 benchmarks. The performance analysis focuses on programming models, optimization technologies and underlying compilers. It measures and compares kernel execution times and data transfer times to/from the GPU. In addition, it utilizes a Performance Ratio metric to conduct an objective comparison. The experimental results show that in general the PGI compiler is able to translate OpenACC kernels into object code that is slightly slower than hand-written CUDA codes for benchmarks that solve the same problem. Also, the data transfer time in OpenACC programs tends to be much faster than in CUDA, while the number of memcpy calls tends to be higher than in CUDA. Overall conclusions were found that OpenACC is a very reliable programming model and a good alternative to CUDA for accelerator devices. For the programs in our test corpus, OpenACC performs as well as CUDA, and in general, OpenACC is better for novices and for programmers targeting multiple platforms.},
%   author = {Xuechao Li and Po-Chou Shih},
%   city = {New York, NY, USA},
%   doi = {10.1145/3234664.3234681},
%   isbn = {9781450364850},
%   journal = {Proceedings of the 2018 2nd High Performance Computing and Cluster Technologies Conference},
%   keywords = {CUDA,OpenACC,Parallel Optimization,Performance comparison},
%   pages = {53–57},
%   publisher = {Association for Computing Machinery},
%   title = {Performance Comparison of CUDA and OpenACC Based on Optimizations},
%   url = {https://doi.org/10.1145/3234664.3234681},
%   year = {2018},
% }
% @inproceedings{Zhao2017,
%   abstract = {Genetic algorithm has been widely studied due to its feasibility and effectiveness. A parallel synthesis method for reversible logic based on the genetic algorithm and the CUDA technique is discussed in this paper. It features the configuration encodings and truth tables prepared and stored in advance for reversible logic gates, chromosomes are composed of encoded reversible logic gates, which contained in individuals (reversible logic circuits), partly parallel fitness evaluation according to logic expected logic functions and optimization objectives, and partly parallel genetic operations such as selection, crossover, and mutation. With these steps assembled together and executed iteratively, reversible logic circuit with correct function and optimal performance can be probably obtained. The experimental results show feasibility and effectiveness of the method proposed, and its advantages over existing non-parallel methods in operation speed and solving ability.},
%   author = {Shuguang Zhao and Chaozheng Wang and Zidan Wang},
%   city = {New York, NY, USA},
%   doi = {10.1145/3057039.3057059},
%   isbn = {9781450348096},
%   journal = {Proceedings of the 9th International Conference on Computer and Automation Engineering},
%   keywords = {CUDA,GPU parallel computing,Genetic algorithm,Reversible logic circuits,Reversible logic gates,Synthesis},
%   pages = {169–173},
%   publisher = {Association for Computing Machinery},
%   title = {Reversible Logic Synthesis Method Based on Genetic Algorithm and Its CUDA Parallel Implementation},
%   url = {https://doi.org/10.1145/3057039.3057059},
%   year = {2017},
% }
% @inproceedings{Rehn2018,
%   abstract = {Hierarchical clustering is a widely-used and well-researched clustering technique. The classical algorithm for agglomerative hierarchical clustering is prohibitively expensive for use with large datasets. Numerous algorithms exist to improve the efficiency of hierarchical clustering for various linkage metrics, and for large datasets. Recent research has proposed approaches for improving the efficiency of hierarchical clustering through parallelism. The newest approaches utilise GPGPU technologies, which facilitate massive parallelism on commodity consumer hardware. Existing GPGPU implementations fail to maximise the number of merges that can be performed in parallel, and feature high use of memory. These limitations prevent existing implementations from achieving the full performance offered by GPGPU. In this paper, we propose a novel GPGPU algorithm for hierarchical clustering of single-dimensional data. Our proposed algorithm exploits the unique characteristics of one-dimensional data to maximise merge parallelism and significantly reduce memory requirements. Validation demonstrates that our proposed algorithm produces equivalent results to the classical algorithm for both the single-linkage and complete-linkage metrics. Benchmarking results show that our algorithm scales well to large datasets, and offers a substantial speed-up over the classical algorithm. Future work will look to extend our proposed approach to larger datasets with higher dimensions.},
%   author = {Adam Rehn and Aidan Possemiers and Jason Holdsworth},
%   city = {New York, NY, USA},
%   doi = {10.1145/3167918.3167929},
%   isbn = {9781450354363},
%   journal = {Proceedings of the Australasian Computer Science Week Multiconference},
%   keywords = {GPU acceleration,agglomerative clustering,parallel},
%   publisher = {Association for Computing Machinery},
%   title = {Efficient Hierarchical Clustering for Single-Dimensional Data Using CUDA},
%   url = {https://doi.org/10.1145/3167918.3167929},
%   year = {2018},
% }

% @inproceedings{Fan2004,
%   author = {Zhe Fan and Feng Qiu and Arie Kaufman and Suzanne Yoakum-Stover},
%   city = {USA},
%   doi = {10.1109/SC.2004.26},
%   isbn = {0769521533},
%   journal = {Proceedings of the 2004 ACM/IEEE Conference on Supercomputing},
%   keywords = {GPU cluster,computational fluid dynamics,data intensive computing,lattice Boltzmann model,urban airborne dispersion},
%   pages = {47},
%   publisher = {IEEE Computer Society},
%   title = {GPU Cluster for High Performance Computing},
%   url = {https://doi.org/10.1109/SC.2004.26},
%   year = {2004},
% }

% @article{Niemeyer2014,
%   author = {Kyle E Niemeyer and Chih-Jen Sung},
%   city = {USA},
%   doi = {10.1007/s11227-013-1015-7},
%   issn = {0920-8542},
%   issue = {2},
%   journal = {J. Supercomput.},
%   keywords = {CUDA,Computational fluid dynamics (CFD),Graphics processing unit (GPU),Laminar flows,Reactive flow,Turbulent flow},
%   month = {2},
%   pages = {528–564},
%   publisher = {Kluwer Academic Publishers},
%   title = {Recent Progress and Challenges in Exploiting Graphics Processors in Computational Fluid Dynamics},
%   volume = {67},
%   url = {https://doi.org/10.1007/s11227-013-1015-7},
%   year = {2014},
% }

% @inproceedings{Stam1999,
%   author = {Jos Stam},
%   city = {USA},
%   doi = {10.1145/311535.311548},
%   isbn = {0201485605},
%   journal = {Proceedings of the 26th Annual Conference on Computer Graphics and Interactive Techniques},
%   keywords = {Navier-Stokes,advected textures,animation of fluids,gaseous phenomena,implicit elliptic PDE solvers,interactive modeling,stable solvers},
%   pages = {121–128},
%   publisher = {ACM Press/Addison-Wesley Publishing Co.},
%   title = {Stable Fluids},
%   url = {https://doi.org/10.1145/311535.311548},
%   year = {1999},
% }

% @inproceedings{Kuba1995,
%   author = {M Kuba and C D Polychronopoulos and K Gallivan},
%   journal = {Supercomputing '95:Proceedings of the 1995 ACM/IEEE Conference on Supercomputing},
%   pages = {72},
%   title = {The Synergetic Effect of Compiler, Architecture, and Manual Optimizations on the Performance of CFD on Multiprocessors},
%   year = {1995},
% }
% @working_paper{Ni2009,
%   author = {Tianyun Ni},
%   institution = {Nvidia Corporation},
%   note = {Nvidia GTC},
%   title = {Direct Compute - Bring GPU Compute to the Mainstream},
%   year = {2009},
% }
% @book{Griebel1998,
%   author = {Michael Griebel and Thomas Dornseifer and Tilman Neunhoeffer},
%   publisher = {SIAM},
%   title = {Numerical simulation in fluid dynamics: a practical introduction},
%   year = {1998},
% }

% @article{Harlow1965,
%   author = {Francis H. Harlow and J. Eddie Welch},
%   doi = {10.1063/1.1761178},
%   issn = {00319171},
%   issue = {12},
%   journal = {Physics of Fluids},
%   pages = {2182},
%   title = {Numerical Calculation of Time-Dependent Viscous Incompressible Flow of Fluid with Free Surface},
%   volume = {8},
%   url = {https://aip.scitation.org/doi/10.1063/1.1761178},
%   year = {1965},
% }

% @book_section{Muller2010,
%   abstract = {The fused multiply-add (FMA) instruction makes it possible to evaluate ab + c, where a, b, and c are floating-point numbers, with one final rounding only.},
%   author = {Jean-Michel Muller and Nicolas Brisebarre and Florent de Dinechin and Claude-Pierre Jeannerod and Vincent Lefèvre and Guillaume Melquiond and Nathalie Revol and Damien Stehlé and Serge Torres and Jean-Michel Muller and Nicolas Brisebarre and Florent de Dinechin and Claude-Pierre Jeannerod and Vincent Lefèvre and Guillaume Melquiond and Nathalie Revol and Damien Stehlé and Serge Torres},
%   doi = {10.1007/978-0-8176-4705-6_5},
%   journal = {Handbook of Floating-Point Arithmetic},
%   pages = {151-179},
%   publisher = {Birkhäuser Boston},
%   title = {The Fused Multiply-Add Instruction},
%   url = {https://link.springer.com/chapter/10.1007/978-0-8176-4705-6_5},
%   year = {2010},
% }

